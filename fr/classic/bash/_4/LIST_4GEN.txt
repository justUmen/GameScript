#[ -d "$HOME/.GameScript_bash4" ] && echo "Erreur innatendu, ${HOME}/.GameScript_bash4 existe déjà sur votre système ! Supprimez ce dossier $HOME/.GameScript_bash4 et relancer ce script." && exit
#mkdir $HOME/.GameScript_bash4
#cd $HOME/.GameScript_bash4
Dans le chapitre précédent, nous avons vu comment créer et modifier les fichiers textes.
Ici nous allons continuer sur d'autres controles sur ces fichiers.
+Commencez par créer un nouveau fichier 'test' avec comme contenu le mot 'bonjour'.
!echo bonjour>test£Non
+Créez un nouveau dossier nommé 'DIR'.
!mkdir DIR£Non
+Affichez les éléments du répertoire courant.
!ls£Non
Pour déplacer un fichier il faudra utiliser la commande ${code}mv${reset}.
'm' et 'v' sont les consonnes de 'move', le mot anglais pour 'déplacer'.
+Déplacez donc ce fichier 'test' dans le dossier DIR avec la commande : ${learn}mv test DIR${reset}
!mv test DIR£Non
+Affichez les éléments du dossier 'DIR'.
!ls DIR£Non
+Déplacer le terminal dans le dossier 'DIR'.
!cd DIR£Non
+Affichez le chemin absolu du répertoire courant.
!pwd£Non
+Affichez les éléments du répertoire courant.
!ls£Non
Ici le fichier 'test' a bien été déplacé dans le répertoire 'DIR' avec la commande : ${learn}mv test DIR${reset}
Dans cet exemple, notre premier argument est un fichier ('test') et le second est un dossier. ('DIR')
Comme le deuxième argument est un dossier, la commande aurait pu être : ${learn}mv test DIR/${reset}
Cette version est nettement plus lisible que la première.
Parce que ${code}mv${reset} peut avoir indifféremment en arguments des fichiers ou des dossiers.
Mais si le premier argument est un fichier et que le deuxième est aussi un fichier, qu'est ce que cela veut dire ?
Dans ce contexte le fichier sera déplacé dans un autre fichier avec un nom différent.
Ou pour plus de clarté on peut dire qu'il sera simplement ${voc}renommé${reset}.
Dans votre répertoire courant vous avez toujours ce fichier 'test'.
+Utilisez cette commande pour renommer 'test' en 'test2' : ${learn}mv test test2${reset}
!mv test test2£Non
+Affichez les éléments du répertoire courant.
!ls£Non
+Affichez le contenu du fichier 'test2'.
!cat test2£Non
Le contenu est bien toujours le même, seul le nom du fichier à changé.
+Maintenant créez un nouveau dossier nommé : 'DOS'.
!mkdir DOS£Non
Je le répète, ${code}mv${reset} peut avoir indifféremment en arguments des fichiers ou des dossiers.
C'est à dire que si les deux arguments sont des dossiers, ${code}mv${reset} va encore une fois simplement renommer.
+Maintenant créez un nouveau dossier nommé : 'DOS'.
!mkdir DOS£Non
+Renommer ce dossier 'DOS' en 'DOS2'.
!mv DOS DOS2£Non
+Et affichez les éléments du répertoire courant.
!ls£Non
Attention donc à la commande ${code}mv${reset} qui peut avoir deux rôles différents, déplacer et renommer.
${code}mv${reset} peut également faire les deux en une seule commande.
+Déplacez 'test2' dans 'DOS2' et renommez le 'test' avec : ${learn}mv test2 DOS2/test${reset}
!mv test2 DOS2/test£Non
+Affichez les éléments du répertoire DOS2.
!ls DOS2£Non
Le fichier 'test2' a bien été déplacé dans DOS2 et renommé en 'test3'.
+Affichez le contenu de ce fichier 'test3'.
!cat DOS2/test3£Non
Le contenu est toujours identique.
Si vous ajoutez le texte 'tout le monde', le texte sera ajouté sur une nouvelle ligne.
Parce que lorsque vous utilisez ${code}echo${reset}, il ajoutera par défaut une mise à la ligne à la fin.
Si vous ne voulez pas cette mise à la ligne il faudra utiliser l'option ${learn}-n${reset}.
+Remplacez donc le contenu du fichier 'test3' par 'bonjour', mais sans ce '\\n' automatique à la fin.
!echo -n bonjour>DOS2/test3£Non
+Maintenant ajoutez le texte ' tout le monde', en utisant ${learn}\\"${reset} avec bien évidemment un espace avant 'tout'.
!echo " tout le monde">>DOS2/test3£Non
+Enfin, affichez le contenu de 'test3'.
!cat DOS2/test3£Non
Et voilà, bonjour tout le monde !
Quand une commande ne fait pas exactement ce que voulez qu'elle fasse, visitez son manuel !
Il est très probable qu'une simple option soit la réponse à votre problème.
${code}mv${reset} utilise deux arguments, le premier est ${voc}<SOURCE>${reset} et le deuxième est ${voc}<DESTINATION>${reset}.
Et la syntaxe comme on l'a déjà vu est donc : ${code}mv <SOURCE> <DESTINATION>${reset}
${voc}<SOURCE>${reset} et ${voc}<DESTINATION>${reset} sont à remplacer par les fichiers ou les dossiers voulus.
Lorsqu'une commande a besoin de deux arguments, la plupart du temps cette logique s'applique.
Pour ${voc}copier${reset} ou ${voc}dupliquer${reset} un fichier sur linux il faudra utiliser la commande ${code}cp${reset}.
Son comportement est sensiblement identique à ${code}mv${reset}, sauf que le fichier ${voc}<SOURCE>${reset} ne sera pas supprimée.
+Affichez les éléments du répertoire courant.
!ls£Non
+Copiez donc le fichier 'test3' dans votre répertoire courant.
!cp DOS2/test3 .£Non
Et ici nous avons notre première utilisation pratique du ${code}.${reset} qui je vous le rappelle représente le répertoire courant.
+Listez à nouveau les éléments du répertoire courant.
!ls£Non
Encore une fois ${code}.${reset} étant un dossier, vous pouvez également utiliser ${code}./${reset} à la place.
+Maintenant testez cette commande : ${learn}cp DOS2/test3 .new${reset}
!cp DOS2/test3 .new£Non
+Puis listez les éléments du répertoire courant.
!ls£Non
Ce résultat ne devrait pas vous choquer.
Encore une fois, ${code}.new${reset} et  ${code}./new${reset} représentent deux choses différentes.
${code}.new${reset} est bien évidemment un fichier caché.
+Listez les fichiers cachés du répertoire courant.
!ls -a£Non
Si vous vouliez copier le fichier 'test3' et renommer cette copie en 'new' dans le répertoire courant, la commande sera : ${learn}cp DOS2/test3 ./new${reset}.
Ici la commande ${learn}cp DOS2/test3 .new${reset} est identique à ${learn}cp DOS2/test3 ./.new${reset}.



#rmdir $HOME/.GameScript_bash4


"mv"
"cp"
";"
"&&"
"||"
"nano"

è
é
à

